<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《JS高程》笔记：Promise与异步函数</title>
    <link href="/2022/03/23/%E3%80%8AJS%E9%AB%98%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/"/>
    <url>/2022/03/23/%E3%80%8AJS%E9%AB%98%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>整理《JavaScript高级程序设计》的“Promise与异步函数”章节内容</p><hr><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>​    异步行为是为了优化因计算量大而时间长的操作，避免阻塞线程</p><p>​    JavaScript是单线程的，早期JavaScript程序通过回调函数来表明异步操作 </p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>​    串联多个异步操作需要使用深度嵌套的回调函数（回调地狱/金字塔）</p><hr><h2 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h2><p>​    一种异步程序执行的机制</p><p>​    ES6中推出Promise/A+规范，即Promise类型，是目前主导的异步编程机制</p><h3 id="期约基础"><a href="#期约基础" class="headerlink" title="期约基础"></a>期约基础</h3><p>​    引用类型，可通过new操作符实例化，创建期约需要传入执行器（executor）函数作为参数，若不提供执行器函数，则会抛出<code>SyntaxError</code>（Firefox）/<code>TypeError</code>（Chrome）</p><h4 id="期约状态机"><a href="#期约状态机" class="headerlink" title="期约状态机"></a>期约状态机</h4><blockquote><p>期约是一个有状态的对象，有三种状态：</p><ul><li><p>待定（pending）</p></li><li><p>兑现/解决（fulfilled/resolved）</p></li><li><p>拒绝（reject）</p></li></ul></blockquote><p>​    <img src="https://raw.githubusercontent.com/AtlasRyan/myPic/main/blog/images/2022-03-22_212629.png"></p><p>​    <strong>待定</strong>是期约的最初状态（不必一开始就必须处于待定状态），在待定状态下，期约可以<strong>落定</strong>为另外两种状态，落定过程不可逆，落定后状态不再改变。期约的状态是私有的</p><p>​    期约状态落定为兑现，会有一个私有的内部值；落定为拒绝，会有一个私有的内部理由。二者是可选的，默认值为<code>undefined</code></p><blockquote><p>期约的<strong>执行器函数</strong>主要职责：</p><ul><li><p>初始化期约的异步行为</p></li><li><p>控制状态的最终转换</p></li></ul></blockquote><p>​    控制状态转换通过执行器函数的<em>参数函数</em>实现，它们通常被命名为<code>resolve()</code>和<code>reject()</code>。</p><p>​    调用<code>resolve()</code>会将状态切换为兑现；调用<code>reject()</code>会将状态切换为拒绝并抛出错误</p><p>​    执行器函数是<strong>同步</strong>执行的</p><blockquote><p>通过调用<code>Promise.resolve()</code>方法，实例化一个解决的期约。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>reslove());<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve()<br></code></pre></td></tr></table></figure><p>​    此时，期约的兑现值为<code>Promise.resolve()</code>的第一个参数，多余参数会被忽略，这个参数可以是任何非期约值，包括错误对象，如果是参数本身是期约，相当于传入一个空包装</p><blockquote><p>通过调用<code>Promise.reject()</code>方法，实例化一个拒绝的期约并抛出异步错误（需要通过异步模式捕获）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>reject());<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.reject()<br></code></pre></td></tr></table></figure><p>​    此时，期约的拒绝理由为<code>promise.reject()</code>的第一个参数，该参数可传递给后续的拒绝处理程序，如果参数本身是期约，该期约会成为返回的拒绝期约的理由</p><h3 id="期约的实例方法"><a href="#期约的实例方法" class="headerlink" title="期约的实例方法"></a>期约的实例方法</h3><p>​    <code>Promise.prototype.then()</code>为期约实例添加处理程序，接受两个参数：onResolved处理程序和onRejected处理程序，它们都是可选的，任何非函数类型的参数会被静默忽略。该方法返回一个新的期约实例</p><p>​    <code>Promise.prototype.catch()</code>为期约实例添加拒绝处理程序，接受一个参数：onRejected处理程序。该方法是<code>Promise.prototype.then(null,onRejected)</code>的语法糖。该方法返回一个新的期约实例</p><p>​    <code>Promise.prototype.finally()</code>为期约实例添加onFianlly处理程序，无论期约转化结果如何，它都会执行，主要用于添加清理代码。该方法返回一个新期约实例，大多数情况下表现为父期约的传递</p><p>​    期约落定时，与其状态相关的处理程序会被<strong>排期</strong>（推入消息队列），与添加处理程序和改变状态的顺序无关，该特性被称为非重入（non-reentrancy）</p><p>​    期约中抛出的错误（不包括执行器函数）不会阻止运行时继续执行同步命令</p><h3 id="期约连锁与期约组合"><a href="#期约连锁与期约组合" class="headerlink" title="期约连锁与期约组合"></a>期约连锁与期约组合</h3><p>​    将期约逐个串联起来构成期约连锁</p><p>​    <code>Promise.all()</code>创造的期约会在一组期约全部解决后再解决，该方法接受一个可迭代对象，返回一个新期约。若有一个包含的期约待定，则合成的期约待定；若有一个包含的期约拒绝，则合成的期约也会拒绝；若全部成功解决，则合成期约的解决值为所有包含期约解决值的数组，顺序依照迭代器</p><p>​    <code>Promise.race()</code>返回一个包装期约，为最先解决或拒绝的期约的镜像，该方法接受一个可迭代对象，返回一个新期约。</p><h3 id="期约扩展"><a href="#期约扩展" class="headerlink" title="期约扩展"></a>期约扩展</h3><p>​    三方库中支持但是ECMAScript不支持的特性：期约取消，进度追踪</p><hr><h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p>​    <code>async/await</code>为ES8规范新增</p><p>​    <code>async</code>声明异步函数，没有返回值（返回值为undefined）的函数依旧同步执行，否则返回值会被<code>Promise.resole()</code>包装成一个期约对象</p><p>​    异步函数中抛出错误会返回拒绝的期约</p><p>​    <code>await</code>关键字用来暂停异步代码执行，等待期约解决</p><p>​    等待会抛出错误的同步操作，会返回拒绝的期约</p><p>​    <code>await</code>不能用于顶级上下文如<code>&lt;script&gt;</code>标签或模块，可以定义并立即调用异步函数</p><p><img src="https://raw.githubusercontent.com/AtlasRyan/myPic/main/blog/images/2022-03-23_173845.png" alt="2022-03-23_173845"></p><p>​    异步函数特质不会扩散到嵌套函数。<code>await</code>关键字不能出现在箭头函数中</p><p>​    JavaScript执行遇到<code>await</code>关键字后，会纪录在哪里暂停执行，待到其右边值可用后，再向消息队列中推送一个任务，此任务恢复异步函数的执行</p><p><img src="https://raw.githubusercontent.com/AtlasRyan/myPic/main/blog/images/2022-03-23_175400.png" alt="2022-03-23_175400"></p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    期约可以用来表示异步执行的代码块，也可以表示异步计算的值</p><p>​    异步函数可以暂停执行，而不阻塞主线程</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的循环遍历方法</title>
    <link href="/2021/10/07/JavaScript%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/"/>
    <url>/2021/10/07/JavaScript%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>整理一些常见的循环遍历方法</p><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><ol><li><p><code>forEach()</code></p><p>调用数组中的每一个元素传递给回调函数，不改变原数组，没有返回值，无法跳出循环，只适用于Array对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">array.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></td></tr></table></figure></li><li><p><code>map()</code></p><p>按照原始数组顺序处理元素，返回新数组，不改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></td></tr></table></figure></li><li><p><code>for ... of</code></p><p>遍历可迭代对象要迭代的数据（属性值），可中断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(variable <span class="hljs-keyword">of</span> iterable) &#123;<br>statement<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>filter()</code></p><p>返回满足条件的元素组成的新数组，不改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></td></tr></table></figure></li><li><p><code>some(), every()</code></p><p>遍历检验数组，返回布尔值，不改变数组</p><p>some()方法遇到符合条件元素即返回true，不再检查余下元素；every()方法在所有元素均符合条件后才返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br><span class="hljs-function"><span class="hljs-title">array</span>.<span class="hljs-title">every</span>(<span class="hljs-params"><span class="hljs-keyword">function</span>(currentValue, index, arr), thisValue</span>)</span><br></code></pre></td></tr></table></figure></li><li><p><code>reduce(), reduceRight()</code></p><p>接受一个函数作为累加器，为每一个元素依次执行回调函数，两方法遍历顺序相反，添加初始值则改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">total, currentValue, currentIndex, arr</span>), <span class="hljs-title">initialValue</span>)</span><br><span class="hljs-function"><span class="hljs-title">array</span>.<span class="hljs-title">reduceRight</span>(<span class="hljs-params"><span class="hljs-keyword">function</span>(total, currentValue, currentIndex, arr), initialValue</span>)</span><br></code></pre></td></tr></table></figure></li><li><p><code>keys(), values(), entries()</code></p><p>三者都返回一个与数组有关的可迭代对象</p><ul><li>keys()返回数组的索引值</li><li>values()返回数组的元素</li><li>entries()返回数组的键值对</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.keys()<br>array.values()<br>array.entires()<br></code></pre></td></tr></table></figure><hr></li></ol><h2 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h2><ol><li><p><code>for...in</code></p><p>遍历对象的可枚举属性名，会遍历原型链上的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(variable <span class="hljs-keyword">in</span> object) &#123;<br>statement<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Object.keys(), Object.values(), Object.entries()</code></p><p>三者均接受对象作为参数，返回与可枚举属性有关的数组</p><ul><li>Object.keys()返回包含对象属性名的数组</li><li>Object.values()返回包含对象属性值的数组</li><li>Object.entries()返回包含名值对的数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">id</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;jack&#x27;</span>,<br>    <span class="hljs-attr">age</span> : <span class="hljs-number">22</span><br>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(obj))<span class="hljs-comment">//[&#x27;id&#x27;, &#x27;name&#x27;, &#x27;age&#x27;]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(obj))<span class="hljs-comment">//[1, &#x27;jack&#x27;, 22 ]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(obj))<span class="hljs-comment">//[[&#x27;id&#x27;, 1], [&#x27;name&#x27;, &#x27;jack&#x27;], [&#x27;age&#x27;, &#x27;22&#x27;]]</span><br></code></pre></td></tr></table></figure></li><li><p><code>Object.getOwnPropertyNames()</code></p><p>类似于Object.keys()方法，但是可以返回不可枚举属性(不包括Symbol值作为名称的属性)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>]<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj))<span class="hljs-comment">//[&#x27;0&#x27;, &#x27;1&#x27;, &#x27;length&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>Reflect.ownKeys()</code></p><p>返回一个包含对象自身所有属性的数组，等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj).concat(<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(obj))<br></code></pre></td></tr></table></figure><hr></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>for</li><li>while</li><li>do/while</li><li>for await of</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/07/hello-world/"/>
    <url>/2021/10/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
